% File: 5_hien_thuc_soc/5.1_moi_truong_hien_thuc.tex

Để quá trình hiện thực hóa hệ thống SoC diễn ra đồng bộ và chính xác từ mức thiết kế phần cứng (RTL) đến lớp phần mềm điều khiển (Firmware), đề tài sử dụng một hệ thống các công cụ chuyên dụng, đảm bảo tính tương thích chặt chẽ giữa kiến trúc tập lệnh RISC-V và nền tảng FPGA.

\subsection{Môi trường thiết kế và kiểm thử phần cứng}
Quá trình thiết kế logic cho hệ thống SoC được thực hiện chủ yếu trong môi trường \textbf{Xilinx Vivado Design Suite}. Đây là nền tảng thiết kế tích hợp (IDE) cho phép quản lý các khối IP tùy biến, thực hiện các bước từ phân tích logic, tổng hợp (Synthesis) cho đến việc tối ưu hóa và hiện thực hóa (Implementation). Toàn bộ các phân hệ chức năng, bao gồm lõi xử lý PicoRV32, hệ thống Bus, Video Streaming và các bộ điều khiển ngoại vi như UART, SPI, I2C, OSPI, TIMER, GPIO đều được mô tả bằng ngôn ngữ \textbf{Verilog HDL}. Việc sử dụng ngôn ngữ mô tả phần cứng ở mức thanh ghi (RTL) giúp nhóm thiết kế kiểm soát chính xác tài nguyên logic trên FPGA và hướng tới ASIC, đảm bảo hệ thống đáp ứng được các ràng buộc khắt khe về định thời (Timing constraints) để vận hành ổn định tại tần số 200 MHz.

Trong giai đoạn xác minh thiết kế, công cụ \textbf{Vivado Simulator} đóng vai trò then chốt trong việc kiểm tra tính đúng đắn về mặt chức năng (Functional Verification). Tất cả các khối IP tự thiết kế đều phải trải qua quá trình mô phỏng thông qua hệ thống Testbench trước khi tích hợp vào hệ thống tổng thể. Quy trình này cho phép phát hiện sớm các lỗi về giao thức bắt tay trên bus AXI, logic điều phối dữ liệu của bộ gia tốc CNN và khả năng xử lý dòng dữ liệu của hệ thống Video Streaming. Đối với các lỗi phát sinh trong điều kiện thực tế trên phần cứng, lõi \textbf{Integrated Logic Analyzer (ILA)} được nhúng trực tiếp vào trong chip để giám sát các tín hiệu nội bộ theo thời gian thực, giúp gỡ lỗi các giao tiếp vật lý phức tạp như Camera/HDMI DVP, AXI,....

% File: 5_hien_thuc_soc/5.1_moi_truong_hien_thuc.tex

\subsection{Môi trường phát triển phần mềm và quy trình nhúng mã}
Phần mềm điều khiển hệ thống được phát triển dựa trên ngôn ngữ C/C++ tiêu chuẩn, cho phép tận dụng hệ sinh thái mã nguồn mở phong phú của kiến trúc RISC-V. Để chuyển đổi mã nguồn thành các tệp thực thi tương thích với phần cứng đề xuất, đề tài sử dụng bộ công cụ \textbf{RISC-V GNU Toolchain}. Trình biên dịch \texttt{riscv32-unknown-elf-gcc} được cấu hình với tham số \textbf{-march=rv32im} và \textbf{-mabi=ilp32}, tạo ra mã máy tối ưu hóa cho tập lệnh số nguyên cơ bản của lõi PicoRV32.

Điểm cốt lõi trong quy trình hiện thực hóa phần mềm là cơ chế nạp chương trình hai giai đoạn, giúp biến SoC từ một thiết kế phần cứng cố định thành một nền tảng lập trình nhúng đa năng. Trong giai đoạn tổng hợp trên Vivado, chỉ có khối bộ nhớ khởi động \textbf{BMEM} được nhúng sẵn chương trình \textbf{Bootloader} dưới dạng tệp tin Instruction Hex (.hex). Ngay khi hệ thống khởi vận, chương trình Bootloader này sẽ tự động thiết lập các giao thức cần thiết để đọc dữ liệu từ bộ nhớ Flash ngoại vi và chuyển vào bộ nhớ lệnh \textbf{IMEM}.

Cơ chế này mang lại sự thuận tiện vượt trội cho người dùng trong quá trình phát triển ứng dụng. Thay vì phải tái tổng hợp (Re-synthesis) và nạp lại toàn bộ tệp tin cấu hình FPGA (\texttt{.bit}) mỗi khi thay đổi phần mềm — một quy trình vốn tiêu tốn nhiều thời gian — người lập trình chỉ cần biên dịch chương trình C/C++ mới và cập nhật vào bộ nhớ Flash. Sau khi hoàn tất quá trình nạp dữ liệu vào IMEM, Bootloader sẽ thực hiện lệnh nhảy tới địa chỉ khởi chạy ứng dụng. Giải pháp này giúp tách biệt hoàn toàn giữa lớp hạ tầng phần cứng và lớp ứng dụng người dùng, tạo điều kiện cho việc gỡ lỗi nhanh chóng và triển khai linh hoạt các bài toán khác nhau, từ quản trị hệ thống đơn thuần đến các thuật toán xử lý dữ liệu phức tạp.