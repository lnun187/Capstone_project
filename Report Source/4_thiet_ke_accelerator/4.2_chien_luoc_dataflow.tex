
Để xử lý các Feature Map kích thước lớn trên tài nguyên phần cứng giới hạn, chúng tôi áp dụng chiến lược phân mảnh dữ liệu (Tiling) không chồng lấn. Mục này sẽ trình bày chi tiết cách thức chia nhỏ không gian dữ liệu và thuật toán điều phối các bước tính toán (Passes).
\subsection{Định nghĩa khái niệm "Tile" (Mảnh dữ liệu)}
Trong kiến trúc này, một "Tile" được định nghĩa là một phần nhỏ của khối dữ liệu gốc với kích thước được tối ưu hóa cho dung lượng bộ nhớ on-chip. Hệ thống xử lý ba loại Tile chính tương ứng với ba luồng dữ liệu. Đầu tiên, Input Tile (Mảnh đầu vào) là khối dữ liệu được cắt ra từ Input Feature Map gốc với kích thước $T_c \times T_h \times W$. Việc giới hạn số kênh nạp vào là $T_c$ và chiều cao là $T_h$ giúp dữ liệu vừa vặn với bộ nhớ đệm, trong khi chiều rộng $W$ được giữ nguyên để tận dụng tính liên tục của dữ liệu trong bộ nhớ (Burst Read). Tiếp theo, Weight Tile (Mảnh trọng số) tập hợp các bộ lọc cần thiết để xử lý cho Input Tile hiện tại, có kích thước $T_m \times T_c \times R \times S$. Cuối cùng, kết quả tính toán tương ứng tạo ra Output Tile (Mảnh đầu ra) với kích thước $T_m \times T_h \times W$.
\subsection{Phương pháp Phân mảnh không gian dữ liệu (Space Partitioning)}

Không gian tính toán của một lớp tích chập được định nghĩa bởi ba chiều chính: Chiều cao không gian ($H$), Chiều sâu kênh đầu vào ($C$), và Số lượng bộ lọc/kênh đầu ra ($M$). Chúng tôi chia nhỏ không gian này thành các khối (Block/Tile) độc lập dựa trên tham số phần cứng.

\subsubsection{Công thức chia khối (Block Calculation)}
Giả sử phần cứng có khả năng xử lý song song một khối dữ liệu kích thước $T_c \times T_h \times W$ và tạo ra $T_m$ kênh đầu ra. Số lượng khối (Blocks) trên mỗi chiều được tính như sau:

\begin{itemize}
    \item \textbf{Số khối theo chiều dọc ($N_h$):} Ảnh đầu vào chiều cao $H$ được cắt thành $N_h$ phần không chồng lấn.
    \begin{equation}
        N_h = \lceil \frac{H}{T_h} \rceil
    \end{equation}
    Ví dụ: Với $H=21, T_h=11$, ta có $N_h = 2$ khối (Khối 0: hàng 0-10; Khối 1: hàng 11-20).
    
    \item \textbf{Số khối kênh đầu vào ($N_c$):} Tổng $C$ kênh được chia thành $N_c$ nhóm.
    \begin{equation}
        N_c = \lceil \frac{C}{T_c} \rceil
    \end{equation}
    
    \item \textbf{Số khối kênh đầu ra ($N_m$):} Tổng $M$ bộ lọc được chia thành $N_m$ nhóm.
    \begin{equation}
        N_m = \lceil \frac{M}{T_m} \rceil
    \end{equation}
\end{itemize}
Một đơn vị xử lý cơ sở, gọi là \textbf{1 Pass}, chính là quá trình hệ thống xử lý hoàn tất cho một cặp Input Tile và Weight Tile để cập nhật giá trị cho một Output Tile.
\subsection{Mô hình hóa toán học và Tham số thiết kế}
\label{subsec:math_model}

Để hiện thực hóa chiến lược phân mảnh, chúng tôi xây dựng mô hình toán học cho lớp tích chập thứ $i$. Các ký hiệu và tham số thiết kế được chuẩn hóa trong Bảng \ref{tab:design_params}.

\begin{table}[H]
\centering
\caption{Bảng tham số thiết kế và ánh xạ ký hiệu}
\label{tab:design_params}
\begin{tabularx}{\textwidth}{|l|c|X|}
\hline
\textbf{Nhóm tham số} & \textbf{Ký hiệu} & \textbf{Mô tả} \\ \hline
\multirow{2}{*}{Filter} & $S, R$ & Độ rộng ($w_f$) và Độ dài ($h_f$) của bộ lọc \\ \cline{2-3} 
 & $N_f$ & Tổng số bộ lọc (Filters) \\ \hline
\multirow{3}{*}{Feature Map} & $W, H, C$ & Kích thước Input Feature Map (Rộng, Dài, Số kênh) \\ \cline{2-3} 
 & $W_{out}, H_{out}, N_f$ & Kích thước Output Feature Map \\ \hline
\multirow{3}{*}{Tiling (Pass)} & $T_h$ & Chiều cao IFM nạp trong 1 pass ($h$) \\ \cline{2-3} 
 & $T_c$ & Số kênh IFM tính toán song song ($k$) \\ \cline{2-3} 
 & $T_m$ & Số bộ lọc tính toán song song ($m$) \\ \hline
\multirow{2}{*}{Output Tile} & $T_{ho}$ & Chiều cao OFM hợp lệ tạo ra trong 1 pass ($h_o$) \\ \hline
Khác & $P, Str$ & Padding và Stride \\ \hline
\end{tabularx}
\end{table}

\subsubsection{Công thức tính kích thước không gian toàn cục}
Dựa trên nguyên lý tích chập, một layer cần xử lý khối dữ liệu vào $W \times H \times C$. Kích thước không gian của Output Feature Map (OFM) toàn cục được tính như sau:

\begin{equation}
    W_{out} = \left\lfloor \frac{W - S + 2P}{Str} \right\rfloor + 1; \quad H_{out} = \left\lfloor \frac{H - R + 2P}{Str} \right\rfloor + 1
\end{equation}

\subsubsection{Tính toán kích thước Output Tile theo cơ chế Ping-Pong}
Trong chiến lược phân mảnh đề xuất, chiều cao đầu ra hợp lệ ($T_{ho}$) không cố định mà phụ thuộc vào việc hệ thống có tận dụng được dữ liệu dôi ra (Residual Data) từ pass trước đó hay không.

Giả sử bước trượt $Str = 1$ và Padding được xử lý tại biên ảnh gốc, số lượng hàng Output hợp lệ ghi xuống DRAM trong mỗi Pass được xác định bởi công thức:

\begin{equation}
    T_{ho} = 
    \begin{cases}
        T_h - R + 1 & \text{nếu là Tile đầu tiên } (Tile\_idx = 0) \\
        T_h & \text{nếu là các Tile tiếp theo } (Tile\_idx > 0)
    \end{cases}
\end{equation}

\textbf{Giải thích:}
\begin{itemize}
    \item \textbf{Tile đầu tiên ($T_{ho} = T_h - R + 1$):} Do không có dữ liệu tích lũy từ phía trên, $R-1$ hàng cuối cùng không đủ dữ liệu lân cận để hoàn thành phép tính tích chập, trở thành dữ liệu dôi ra (Residual) được lưu vào Buffer.
    \item \textbf{Các Tile tiếp theo ($T_{ho} = T_h$):} Hệ thống nạp $T_h$ hàng input mới, kết hợp với $R-1$ hàng residual từ tile trước đó. Điều này cho phép hoàn thiện $R-1$ hàng biên cũ và tính trọn vẹn phần thân mới, tạo ra đủ $T_h$ hàng output hợp lệ.
\end{itemize}

\subsubsection{Phân tích số lượng Pass và Dữ liệu biên}
Tổng số pass cần thiết được xác định bởi tích số các phân mảnh trên 3 chiều:

\begin{equation}
    Total\_Pass = \underbrace{\left\lceil \frac{C}{T_c} \right\rceil}_{N_c} \times \underbrace{\left\lceil \frac{H}{T_h} \right\rceil}_{N_h} \times \underbrace{\left\lceil \frac{N_f}{T_m} \right\rceil}_{N_m}
\end{equation}

Do kích thước layer thường không chia hết cho kích thước Tile, lượng dữ liệu xử lý trong các pass cuối (Boundary Passes) sẽ khác biệt:

\begin{itemize}
    \item \textbf{Phân mảnh theo kênh ($C$):} Để hoàn thiện một phần output, cần thực hiện $\lceil C / T_c \rceil$ pass tích lũy. Pass cuối cùng xử lý phần dư: $T_h \times W \times (C \pmod{T_c})$.
    
    \item \textbf{Phân mảnh theo chiều dọc ($H$):} Cần $\lceil H / T_h \rceil$ bước trượt dọc.
    \begin{itemize}
        \item Pass cuối cùng (Last Tile) xử lý chiều cao input dư: $H_{rem} = H \pmod{T_h}$.
        \item Số hàng Output hợp lệ của Pass cuối cũng tuân theo logic Ping-Pong: Nếu $H_{rem}$ đủ lớn, nó sẽ tạo ra $H_{rem}$ hàng output (do thừa hưởng biên trên).
    \end{itemize}
    
    \item \textbf{Phân mảnh theo số bộ lọc ($N_f$):} Pass cuối xử lý số bộ lọc dư: $N_f \pmod{T_m}$.
\end{itemize}

\subsubsection{Trường hợp Depthwise Convolution}
Đối với Depthwise Convolution ($N_f = C$), quy trình được đơn giản hóa do không có vòng lặp tích lũy kênh ($N_c = 1$):
\begin{itemize}
    \item Tổng số Pass: $\lceil H / T_h \rceil \times \lceil N_f / T_m \rceil$.
    \item Kích thước Output Tile $T_{ho}$ vẫn tuân theo quy tắc (3) nêu trên.
\end{itemize}
\subsection{Thuật toán Điều phối Pass (Pass Scheduling)}

Trình tự thực hiện các Pass phụ thuộc vào loại tích chập (Standard hay Depthwise) để tối ưu hóa việc tái sử dụng dữ liệu biên (như đã phân tích ở mục Dữ liệu dôi ra).

\subsubsection{Thuật toán cho Standard Convolution}
Trong Standard Convolution, một điểm ảnh đầu ra cần tổng hợp dữ liệu từ \textbf{tất cả} các khối kênh đầu vào ($N_c$). Do đó, ta cần vòng lặp tích lũy (Reduction Loop) chạy qua $N_c$ trước khi chuyển sang khối chiều cao khác.

\begin{algorithm}[H]
\caption{Lịch trình Pass cho Standard Convolution}
\label{alg:pass_standard}
\SetAlgoLined
\DontPrintSemicolon
\KwIn{$N_m$ (Output Blocks), $N_h$ (Height Blocks), $N_c$ (Input Blocks)}
% Duyệt qua từng nhóm Filter (Output Channels)
\For{$m = 0$ \textbf{to} $N_m - 1$}{
    \textit{1. Load Weights for Output Block $m$ (Weight Stationary)}\;
    % Duyệt qua chiều cao (để tận dụng Ping-Pong buffer cho biên)
    \For{$h = 0$ \textbf{to} $N_h - 1$}{
        % Vòng lặp Tích lũy (Reduction): Cộng dồn kết quả từ các nhóm kênh Input
        \For{$c = 0$ \textbf{to} $N_c - 1$}{
            \textbf{Pass $(m, h, c)$:} \;
            - Nạp Input Block $(c, h)$ kích thước $T_c \times T_h$\;
            - Tính toán với Weight Block $(m, c)$\;
            - Cộng dồn kết quả vào Buffer hiện tại (A hoặc B)\;
        }
        \textit{2. Xử lý biên \& Ghi Output:}\;
        - Sau khi cộng đủ $N_c$ passes: Output Block $(m, h)$ đã hoàn tất (Valid).\;
        - Ghi phần Valid xuống DRAM.\;
        - Hoán đổi Ping-Pong Buffer (để dùng phần Dôi ra cho $h+1$).\;
    }
}
\end{algorithm}

\subsubsection{Thuật toán cho Depthwise Convolution}
Trong Depthwise Convolution, kênh Input thứ $i$ chỉ tính toán với kênh Filter thứ $i$. Do đó $N_c = N_m$ (số nhóm kênh Input bằng số nhóm kênh Output) và không có sự cộng dồn chéo giữa các nhóm. Vòng lặp tích lũy biến mất.

\begin{algorithm}[H]
\caption{Lịch trình Pass cho Depthwise Convolution}
\label{alg:pass_dw_a}
\SetAlgoLined
\DontPrintSemicolon
\KwIn{$N_m$ (Channel Groups), $N_h$ (Height Blocks)}
% Duyệt qua từng nhóm Kênh (Channel Groups)
% Ở đây N_m đóng vai trò là cả nhóm Input lẫn Output (vì 1-1 mapping)
\For{$g = 0$ \textbf{to} $N_m - 1$}{
    \textit{1. Load Weights for Group $g$}\;
    % Duyệt dứt điểm chiều cao cho nhóm kênh này
    \For{$h = 0$ \textbf{to} $N_h - 1$}{
        \textbf{Pass $(g, h)$:} \;
        - Nạp Input Block $(g, h)$ kích thước $T_c \times T_h$\;
        - Tính toán với Weight Block $g$\;
        - Tạo ra ngay kết quả Output Block $(g, h)$ (không cần cộng dồn)\;
        \textit{2. Xử lý biên \& Ghi Output:}\;
        - Ghi ngay phần Valid xuống DRAM.\;
        - Hoán đổi Ping-Pong Buffer (lưu phần Dôi ra cho $h+1$).\;
    }
}
\end{algorithm}
\begin{figure}[h!]
    \centering
    
    % --- Hàng 1: Hình (a) ---
    \begin{subfigure}[b]{0.8\textwidth} % Tăng độ rộng lên (ví dụ 0.8 hoặc 0.9)
        \centering
        \includegraphics[width=\linewidth]{image/4/std_conv_pass.png}
        \caption{Standard Convolution ($H=21, M=2$)}
        \label{fig:pass_div_std}
    \end{subfigure}
    
    \par\bigskip % Xuống dòng và tạo khoảng cách lớn giữa 2 hình
    % \vspace{0.5cm} % Hoặc dùng lệnh này để chỉnh khoảng cách cụ thể
    
    % --- Hàng 2: Hình (b) ---
    \begin{subfigure}[b]{0.8\textwidth} 
        \centering
        \includegraphics[width=\linewidth]{image/4/dw_conv_pass.png}
        \caption{Depthwise Convolution ($H=21, M=21$)}
        \label{fig:pass_div_dw}
    \end{subfigure}
    
    \caption{Minh họa chiến lược phân chia Pass cho hai loại tích chập với $T_h=11$. (a) Standard Convolution chia thành 2 phần theo chiều dọc và tích lũy theo chiều sâu. (b) Depthwise Convolution xử lý độc lập từng nhóm kênh và chia 2 phần theo chiều dọc.}
    \label{fig:pass_division_strategy}
\end{figure}

\subsection{Phân tích vấn đề tại biên và Dữ liệu dôi ra}

Mặc dù chiến lược phân mảnh dữ liệu được áp dụng trên cả chiều kênh và chiều không gian, tác động của chúng lên luồng dữ liệu là khác nhau.
\begin{itemize}
    \item Việc chia nhỏ chiều kênh ($C, M$) dẫn đến bài toán tích lũy tổng riêng (Partial Sum Accumulation).
    \item Việc chia nhỏ chiều không gian ($H$) dẫn đến bài toán thiếu dữ liệu vùng lân cận cho cửa sổ trượt (Sliding Window Boundary).
\end{itemize}

Mục này tập trung phân tích vấn đề tại biên không gian, nguyên nhân chính dẫn đến sự cần thiết của cơ chế Ping-Pong Buffer đặc thù.

\subsubsection{Cơ sở hình thành Dữ liệu dôi ra}
Khi bộ lọc trượt theo chiều dọc, tại các hàng cuối cùng của một Tile không gian (gọi là Tile $H_k$), bộ lọc cần dữ liệu của các hàng tiếp theo (thuộc Tile $H_{k+1}$) để hoàn thành phép tính.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{image/4/du_lieu_doi_ra.png} % Giảm width xuống 0.8 để hình không quá to
    \caption{Sơ đồ minh họa quá trình tính toán tích chập và sự hình thành dữ liệu dôi ra (Residual Data) trong một pass với tile đầu vào $T_h=4$ và bộ lọc kích thước $3 \times 3$ trong trường hợp số kênh của ifmap feature là 1.}
    \label{fig:residual_data_generation}
\end{figure}
Xét ví dụ cụ thể với Tile đầu vào có kích thước chiều cao $T_h = 4$ (các hàng 0, 1, 2, 3) và bộ lọc kích thước $3 \times 3$. Khi thực hiện tích chập:
\begin{itemize}
    \item \textbf{Hàng 0, 1:} Có đầy đủ dữ liệu lân cận (trong phạm vi Tile hiện tại) $\rightarrow$ Tạo ra kết quả hoàn chỉnh (\textit{Valid Output}).
    \item \textbf{Hàng 2:} Cần dữ liệu hàng [2, 3, \textbf{4}]. Thiếu hàng 4 (thuộc Tile $H_{k+1}$) $\rightarrow$ Kết quả chưa hoàn thiện.
    \item \textbf{Hàng 3:} Cần dữ liệu hàng [3, \textbf{4}, \textbf{5}]. Thiếu hàng 4, 5 (thuộc Tile $H_{k+1}$) $\rightarrow$ Kết quả chưa hoàn thiện.
\end{itemize}

Các kết quả tại hàng 2 và 3 được gọi là \textbf{Dữ liệu dôi ra (Residual Data)}. Số lượng hàng dôi ra luôn là $R-1$. Để đảm bảo tính đúng đắn mà không cần nạp lại phần dữ liệu Input [2, 3] khi xử lý Tile $H_{k+1}$, hệ thống cần lưu trữ các giá trị dôi ra này và cộng dồn chúng với kết quả tính toán từ Tile tiếp theo.

\subsection{Cơ chế Ping-Pong Buffer và Logic xử lý hàng hợp lệ}

Để xử lý dữ liệu dôi ra (Residual Data) tại biên dưới của mỗi tile mà không cần nạp lại Input, hệ thống sử dụng hai bộ đệm đầu ra $Buffer_A$ và $Buffer_B$ hoạt động luân phiên.

Điểm quan trọng trong chiến lược này là số lượng hàng đầu ra hợp lệ (Valid Rows) sẽ khác nhau giữa Tile đầu tiên và các Tile tiếp theo:

\begin{itemize}
    \item \textbf{Tile đầu tiên ($h=0$):} Do không có dữ liệu tích lũy từ phía trên, bộ lọc trượt qua $T_h$ hàng đầu vào chỉ tạo ra được $T_h - R + 1$ hàng đầu ra hoàn chỉnh. $R-1$ hàng cuối cùng là dữ liệu dôi ra.
    \item \textbf{Các Tile tiếp theo ($h > 0$):} Nhờ tận dụng $R-1$ hàng dôi ra từ bước trước (đã lưu trong Buffer), hệ thống sẽ hoàn thiện được các hàng này. Tổng số hàng hoàn chỉnh được ghi xuống DRAM trong bước này là đủ $T_h$ hàng.
\end{itemize}

\subsection{Thuật toán Điều phối và Xoay vòng bộ nhớ}

Thuật toán \ref{alg:pass_std_part1}, \ref{alg:pass_std_part2} và \ref{alg:pass_dw} mô tả chi tiết quy trình quản lý bộ nhớ và luồng dữ liệu, minh họa rõ sự khác biệt khi xử lý Tile đầu tiên và các Tile sau.

% --- PHẦN 1 ---
\begin{algorithm}[H]
    \caption{Lịch trình Pass cho Standard Conv (Phần 1: Tích lũy)}
    \label{alg:pass_std_part1}
    \SetAlgoLined
    \DontPrintSemicolon
    \KwIn{$N_m, N_h, N_c$}
    
    \For{$m = 0$ \textbf{to} $N_m - 1$}{
        \textit{1. Load Weights...}\;
        \For{$h = 0$ \textbf{to} $N_h - 1$}{
            \For{$c = 0$ \textbf{to} $N_c - 1$}{
                \textbf{Pass $(m, h, c)$:} ...\;
                ... (Code phần tích lũy) ...\;
            }
            \textit{(Xem tiếp xử lý biên ở Thuật toán \ref{alg:pass_std_part2})}\;
        }
    }
\end{algorithm}

% --- PHẦN 2 ---
\begin{algorithm}[H]
    \caption{Lịch trình Pass cho Standard Conv (Phần 2: Xử lý biên)}
    \label{alg:pass_std_part2}
    \SetAlgoLined
    \DontPrintSemicolon
    \setcounter{AlgoLine}{10} % (Tuỳ chọn) Đặt lại số dòng để khớp với phần 1
    
    \textit{...Tiếp tục từ vòng lặp h của Thuật toán \ref{alg:pass_std_part1}}\;
    \ForEach{Tile $h$ đã hoàn tất tích lũy}{
        \textit{2. Xử lý biên \& Ghi Output:}\;
        - Kiểm tra điều kiện biên... \;
        - Ghi phần Valid xuống DRAM.\;
        - Hoán đổi Ping-Pong Buffer.\;
    }
\end{algorithm}
\begin{algorithm}[H]
    \caption{Lịch trình Pass cho Depthwise Convolution}
    \label{alg:pass_dw}
    \SetAlgoLined
    \DontPrintSemicolon
    \KwIn{$N_m$ (Số nhóm kênh), $N_h$ (Số khối dọc)}
    \KwOut{DRAM (Valid Output Feature Map)}
    
    % Khởi tạo
    Initialize pointers: $Buf_{curr} \leftarrow A$, $Buf_{next} \leftarrow B$\;
    
    % Vòng lặp Filter Groups
    \For{$m = 0$ \textbf{to} $N_m - 1$}{
        \textit{1. Load Weights for Group $m$}\;
        
        % Vòng lặp chiều cao
        \For{$h = 0$ \textbf{to} $N_h - 1$}{
            \textbf{Pass $(m, h)$:} \;
            - Nạp Input Tile $(m, h)$ kích thước $T_c \times T_h$\;
            - Tính toán Depthwise (1-to-1 mapping)\;
            
            \textit{2. Xử lý biên \& Quản lý Ping-Pong:}\;
            
            % Sử dụng \eIf chuẩn để tránh lỗi
            \eIf{$h == 0$}{
                \textit{// Trường hợp Tile đầu tiên}\;
                - Lưu $T_h - R + 1$ hàng Output hợp lệ vào $Buf_{curr}$\;
                - Lưu phần dư ($R-1$ hàng cuối) vào $Buf_{next}$\;
                - \textbf{Drain:} Ghi $Buf_{curr}$ xuống DRAM\;
            }{
                \textit{// Các Tile tiếp theo (Tận dụng Residual)}\;
                - Hoàn thiện $R-1$ hàng biên (từ $Buf_{curr}$ cũ)\;
                - Tạo thêm các hàng thân mới (đủ $T_h$ hàng)\;
                - Lưu phần dư mới vào $Buf_{next}$\;
                - \textbf{Drain:} Ghi toàn bộ $T_h$ hàng hợp lệ xuống DRAM\;
            }
            
            \textit{3. Chuẩn bị cho tile tiếp theo:}\;
            - Clear $Buf_{curr}$\;
            - \textbf{Swap pointers:} $Buf_{curr} \leftrightarrow Buf_{next}$\;
        }
    }
\end{algorithm}

\textbf{Giải thích cơ chế:}
\begin{enumerate}
    \item Tại vòng lặp $h$, $Buf_{curr}$ đóng vai trò tích lũy kết quả chính, còn $Buf_{next}$ đóng vai trò hứng các giá trị dôi ra (Residual) cho tương lai.
    \item Khi $h=0$: Chúng ta ghi các hàng dôi ra vào đầu $Buf_{next}$.
    \item Khi chuyển sang $h=1$: Ta thực hiện Swap. Lúc này $Buf_{curr}$ (vốn là $Buf_{next}$ cũ) đã có sẵn dữ liệu dôi ra ở các hàng đầu. Việc tính toán tiếp tục cộng dồn vào đó, biến chúng thành kết quả hoàn chỉnh (Valid).
    \item Quá trình ghi xuống DRAM (Drain) ở $h>0$ sẽ ghi toàn bộ $T_h$ hàng, bao gồm cả những hàng vừa được hoàn thiện từ dữ liệu dôi ra.
\end{enumerate}
\begin{figure}[H]
    \centering
    
    % --- Hàng 1: Giai đoạn 1 ---
    \begin{subfigure}[b]{0.8\textwidth}
        \centering
        \includegraphics[width=\linewidth]{image/4/buffer_hinh_a.png}
        \caption{Giai đoạn 1 (Xử lý Tile $H_k$): Buffer A tích lũy kết quả Valid, Buffer B lưu trữ dữ liệu Dôi ra (Residual).}
        \label{fig:ping_pong_state_k}
    \end{subfigure}
    
    \par\bigskip 
    
    % --- Hàng 2: Giai đoạn 2 ---
    \begin{subfigure}[b]{0.8\textwidth} 
        \centering
        \includegraphics[width=\linewidth]{image/4/buffer_hinh_b.png}
        \caption{Giai đoạn 2 (Xử lý Tile $H_{k+1}$): Buffer B hoàn thiện kết quả biên (từ Residual cũ), Buffer A lưu trữ dữ liệu Dôi ra mới.}
        \label{fig:ping_pong_state_k_plus_1}
    \end{subfigure}
    
    \caption{Sơ đồ luồng dữ liệu minh họa cơ chế Ping-Pong Buffer dùng để quản lý vùng dữ liệu dôi ra (Residual Data). Hệ thống luân phiên vai trò của Buffer A và B để đảm bảo tính liên tục của phép tính biên mà không cần nạp lại dữ liệu đầu vào.}
    \label{fig:ping_pong_mechanism}
\end{figure}