Dựa trên chiến lược dòng dữ liệu đã phân tích, nhóm đề xuất kiến trúc phần cứng chuyên dụng mang tên \textbf{Beta Accelerator}. Kiến trúc này được thiết kế để tối ưu hóa khả năng tính toán song song ở mức bộ lọc (Filter parallelism) và mức kênh (Channel parallelism). Đặc biệt, hệ thống sử dụng kiến trúc bộ nhớ tách biệt (Separate Memory Architecture) cho Trọng số và Dữ liệu để tối đa hóa băng thông, đồng thời hỗ trợ cơ chế quản lý bộ nhớ Ping-Pong để che giấu độ trễ truy cập.

\subsection{Sơ đồ khối tổng quát hệ thống}
Sơ đồ tổng thể của Beta Accelerator được trình bày trong Hình \ref{fig:system_arch}. Hệ thống bao gồm các khối chức năng chính sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{image/4/system_arch.png} 
    \caption{Sơ đồ khối tổng quát kiến trúc Beta Accelerator với bus dữ liệu tách biệt}
    \label{fig:system_arch}
\end{figure}

\begin{itemize}
    \item \textbf{Khối Control Data (Controller):} Đóng vai trò bộ điều khiển trung tâm và quản lý giao tiếp với bộ nhớ ngoài. 
    \begin{itemize}
        \item Hệ thống được thiết kế với hai giao tiếp bộ nhớ độc lập: \textbf{Weight Memory Interface} (dành cho trọng số) và \textbf{Activation Memory Interface} (dành cho IFM và OFM).
        \item Do IFM (Input) và OFM (Output) được lưu trữ trên cùng một không gian bộ nhớ Dữ liệu (Activation Memory), khối này chịu trách nhiệm điều phối (arbitration) tài nguyên bus dữ liệu này, quyết định thời điểm thực hiện nạp dữ liệu đầu vào (Load IFM) hoặc ghi kết quả đầu ra (Store OFM) để tránh xung đột. Trong khi đó, luồng nạp Weight có thể diễn ra song song nhờ đường bus riêng.
    \end{itemize}
    
    \item \textbf{Khối Mapping (Dispatcher):} Chịu trách nhiệm phân phối dữ liệu từ hai nguồn bus riêng biệt (Weight Bus và Activation Bus) tới các bộ nhớ đệm cục bộ của từng đơn vị tính toán, đảm bảo tính đồng bộ giữa dữ liệu và trọng số.
    
    \item \textbf{Hệ thống Bộ đệm (Filter + Ifmap Buffer):} Được tổ chức theo cơ chế \textbf{Ping-Pong Buffer} (Double Buffering) để cho phép nạp dữ liệu cho Pass $k+1$ trong khi Pass $k$ đang được tính toán. 
    \begin{itemize}
        \item \textbf{IFM Buffer:} Lưu trữ một tile IFM kích thước $T_h \times W$ của 1 kênh, được nạp từ Activation Memory.
        \item \textbf{Weight Buffer:} Lưu trữ bộ trọng số kích thước $S \times R \times T_m$, được nạp từ Weight Memory riêng biệt.
    \end{itemize}
    
    \item \textbf{Mảng xử lý (Process Array - PA):} Là trái tim tính toán của hệ thống, bao gồm $T_c$ khối PA hoạt động song song. Mỗi khối PA phụ trách xử lý 1 kênh đầu vào (Input Channel) và $T_m$ bộ lọc tương ứng.
    
    \item \textbf{Khối Tổng hợp (Reduction Unit - Mapping + Summary):} Thực hiện chức năng cộng dồn (Reduction) kết quả từ $T_c$ khối PA. Do tích chập là phép tổng trọng số qua các kênh, khối này sẽ cộng giá trị Partial Sum từ các kênh IFM khác nhau để tạo ra $T_m$ giá trị OFM bán hoàn chỉnh.
    
    \item \textbf{Khối Tích lũy (Accumulator):} Sử dụng bộ nhớ Ping-Pong để lưu trữ và cộng dồn kết quả qua các Pass (theo chiều sâu kênh $C$). Khi một điểm ảnh OFM đã được tích lũy đủ số kênh cần thiết, nó sẽ được gửi đi thông qua Activation Bus để ghi vào vùng nhớ Output (OFM) và vị trí nhớ đó sẽ được reset về 0.
\end{itemize}

\subsection{Tổ chức Mảng tính toán (Processing Hierarchy)}
Kiến trúc tính toán được tổ chức theo mô hình phân cấp gồm 3 tầng: Process Array (PA), Process Unit (PU) và Process Element (PE).

\subsubsection{Mảng xử lý (Process Array - PA)}
Khối PA (Hình \ref{fig:pa_arch}) được thiết kế để khai thác tính song song mức kênh đầu ra (Output Channel Parallelism).
\begin{itemize}
    \item Mỗi PA chịu trách nhiệm tính toán cho 1 kênh đầu vào (Input Channel) duy nhất nhưng tạo ra kết quả cho $T_m$ bộ lọc (Filters) khác nhau.
    \item \textbf{Luồng dữ liệu:} Trọng số đầu vào (Input Filter Weights) từ Weight Memory được rẽ nhánh (demultiplex) tới các PU cụ thể. Ngược lại, dữ liệu IFM từ Activation Memory được quảng bá (broadcast) dùng chung cho tất cả các PU trong cùng một PA, giúp tối ưu hóa việc tái sử dụng dữ liệu IFM.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{image/4/pa_arch.png} 
    \caption{Kiến trúc bên trong khối Process Array (PA)}
    \label{fig:pa_arch}
\end{figure}

\subsubsection{Đơn vị xử lý (Process Unit - PU)}
Mỗi PU (Hình \ref{fig:pu_arch}) bao gồm 11 phần tử xử lý (PE) hoạt động song song, tương ứng với khả năng hỗ trợ kích thước bộ lọc tối đa là $11 \times 11$ (chiều cao $R=11$).
\begin{itemize}
    \item Mỗi PE trong PU chịu trách nhiệm tính toán tích chập cho \textbf{1 hàng} của bộ lọc (Filter Row).
    \item Các PE hoạt động đồng bộ. Sau mỗi khoảng thời gian $\Delta T$ chu kỳ, PU sẽ tạo ra một cột kết quả gồm $R$ giá trị tương ứng với $R$ hàng của bộ lọc.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{image/4/pu_arch.png} 
    \caption{Kiến trúc khối Process Unit (PU) với các PE hoạt động song song}
    \label{fig:pu_arch}
\end{figure}

\subsubsection{Phần tử xử lý (Process Element - PE)}
PE là đơn vị tính toán cơ sở nhỏ nhất (Hình \ref{fig:pe_arch}), thực hiện phép tính nhân-cộng (MAC).
\begin{itemize}
    \item \textbf{Filter Buffer:} Lưu trữ $S$ giá trị trọng số của một hàng filter ($1 \times S$). Buffer này hoạt động theo chế độ Weight Stationary, giữ giá trị không đổi trong suốt quá trình thực hiện 1 Pass.
    \item \textbf{Sliding Window Register:} Chứa $S$ giá trị IFM ($1 \times S$). Đây là thanh ghi dịch, sau mỗi $\Delta T$ chu kỳ, dữ liệu sẽ dịch đi 1 vị trí (stride = 1) để thực hiện phép trượt cửa sổ.
    \item Vì mỗi PE chứa 1 bộ nhân và 1 bộ cộng, để tính tích chập 1 hàng kích thước $S$, hệ thống cần $\Delta T = S$ chu kỳ.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{image/4/pe_arch.png} 
    \caption{Cấu trúc bên trong một Process Element (PE)}
    \label{fig:pe_arch}
\end{figure}

\subsection{Đánh giá thời gian thực thi (Performance Estimation)}
Thời gian thực thi của hệ thống phụ thuộc vào loại lớp tích chập (Standard hay Depthwise) do sự khác biệt trong chiến lược luồng dữ liệu.

\subsubsection{Thời gian xử lý một Pass cơ sở ($T_{pass}$)}
Dựa trên kiến trúc Pipeline của các Process Element (PE), thời gian để hoàn thành tính toán cho một tile có chiều cao $T_h$ và độ rộng OFM $W_{out}$ được xác định bởi:

\begin{equation}
    T_{pass} = \left[ (W_{out} - 1) \times (S + U - 1) + S \right] \times T_h
    \label{eq:t_pass}
\end{equation}

Trong đó:
\begin{itemize}
    \item $S$: Kích thước bộ lọc (Filter width).
    \item $U$: Bước trượt (Stride).
    \item $W_{out}$: Chiều rộng của OFM.
    \item $(S + U - 1)$: Số chu kỳ trung bình để tính một điểm ảnh tiếp theo nhờ tối ưu hóa Pipeline (khi $U=1$, thời gian này là $S$).
\end{itemize}

\subsubsection{Tổng thời gian thực thi ($T_{total}$)}

\textbf{Trường hợp 1: Standard Convolution} \\
Với tích chập tiêu chuẩn, mỗi điểm ảnh đầu ra là tổng hợp của tất cả $C$ kênh đầu vào. Hệ thống phải thực hiện vòng lặp tích lũy qua các khối kênh $T_c$.

\begin{equation}
    T_{total\_std} = \underbrace{\left\lceil \frac{N_f}{T_m} \right\rceil}_{\text{Output Blocks}} \times \underbrace{\left\lceil \frac{C}{T_c} \right\rceil}_{\text{Input Blocks}} \times \underbrace{\left\lceil \frac{H}{T_h} \right\rceil}_{\text{Height Blocks}} \times T_{pass}
    \label{eq:total_std}
\end{equation}

\textbf{Trường hợp 2: Depthwise Convolution} \\
Với tích chập chiều sâu, các kênh hoạt động độc lập ($N_f = C$). Hệ thống không cần thực hiện vòng lặp tích lũy kênh đầu vào ($\lceil C/T_c \rceil$ bị loại bỏ). Các nhóm kênh được xử lý song song dựa trên khả năng của phần cứng ($T_m$).

\begin{equation}
    T_{total\_dw} = \underbrace{\left\lceil \frac{N_f}{T_m} \right\rceil}_{\text{Channel Groups}} \times \underbrace{\left\lceil \frac{H}{T_h} \right\rceil}_{\text{Height Blocks}} \times T_{pass}
    \label{eq:total_dw}
\end{equation}

\textbf{Nhận xét:} So với Standard Convolution, Depthwise Convolution giảm được hệ số $\lceil C/T_c \rceil$ lần số lượng tính toán, giúp tăng tốc độ xử lý đáng kể đối với các mạng nhẹ (Lightweight CNNs) như MobileNet.

\subsection{Chiến lược Che giấu độ trễ và Mô hình hiệu năng toàn hệ thống}
\label{subsec:latency_hiding}

Để tối ưu hóa hiệu năng, Beta Accelerator áp dụng kỹ thuật \textbf{Che giấu độ trễ (Latency Hiding)} thông qua cơ chế Ping-Pong Buffer. Mục tiêu là thực hiện song song quá trình tính toán (Computation) và quá trình truyền tải dữ liệu (Data Transfer).

\subsubsection{Cơ chế hoạt động với Bộ nhớ tách biệt}
Nhờ việc tách biệt bộ nhớ Weight và bộ nhớ Activation (IFM/OFM), hệ thống có lợi thế lớn về băng thông:
\begin{itemize}
    \item \textbf{Weight Loading:} Quá trình nạp Weight diễn ra trên bus riêng, do đó hoàn toàn không xung đột với việc nạp IFM hay ghi OFM. Việc nạp Weight cho Pass $i+1$ luôn được thực hiện song song và che giấu bởi thời gian tính toán Pass $i$.
    \item \textbf{Activation Loading/Storing:} IFM và OFM chia sẻ băng thông của Activation Memory. Do đó, vẫn tồn tại sự tranh chấp tài nguyên giữa việc nạp IFM cho Pass tiếp theo và ghi OFM của Pass trước đó.
\end{itemize}

Quy trình hoạt động theo nguyên lý "gối đầu":
\begin{itemize}
    \item Trong khi lõi tính toán đang xử lý Pass $i$, bộ điều khiển DMA đồng thời nạp IFM và Weight cho Pass $i+1$ vào nửa còn lại của Buffer.
    \item Đồng thời, kết quả OFM của Pass $i-1$ (nếu đã hoàn tất) được ghi trả về Activation Memory.
\end{itemize}

\subsubsection{Các kịch bản hiệu năng (Performance Scenarios)}
Do Weight Bus tách biệt, độ trễ nạp Weight thường được che giấu hoàn toàn. Điểm nghẽn (bottleneck) chủ yếu nằm ở sự cân bằng giữa tính toán và truy cập Activation Memory (IFM/OFM).

Gọi $T_{load\_act}$ là thời gian nạp IFM, $T_{store\_act}$ là thời gian ghi OFM, và $T_{comp}$ là thời gian tính toán 1 Pass.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{image/4/image_f8eee0.png} 
    \caption{Biểu đồ thời gian thực thi trong 3 trường hợp cân bằng tải}
    \label{fig:timing_diagrams}
\end{figure}

\textbf{Trường hợp 1: Activation Memory Bound (Nghẽn băng thông dữ liệu)} \\
Xảy ra khi tổng thời gian truy cập Activation Memory lớn hơn thời gian tính toán ($T_{load\_act} + T_{store\_act} \ge T_{comp}$). Lõi tính toán phải chờ bus dữ liệu hoàn thành tác vụ.

\begin{itemize}
    \item \textbf{Đối với Standard Convolution:}
    Cần nạp lại IFM nhiều lần cho các nhóm Filter khác nhau:
    \begin{equation}
        T_{total} \approx \left[ \left( H \times W \times C \times \left\lceil \frac{N_f}{T_m} \right\rceil \right) + \left( H_{out} \times W_{out} \times N_f \right) \right] \times b_{act}
    \end{equation}
    Trong đó $b_{act}$ là số chu kỳ để truyền 1 đơn vị dữ liệu trên Activation Bus.
    
    \item \textbf{Đối với Depthwise Convolution:}
    IFM chỉ cần nạp 1 lần duy nhất do ánh xạ 1-1 giữa kênh Input và Filter:
    \begin{equation}
        T_{total} \approx \left[ \left( H \times W \times C \right) + \left( H_{out} \times W_{out} \times C \right) \right] \times b_{act}
    \end{equation}
\end{itemize}

\textbf{Trường hợp 2: Compute Bound (Nghẽn tính toán)} \\
Xảy ra khi thời gian tính toán lớn hơn tổng thời gian nạp và ghi dữ liệu ($T_{comp} > T_{load\_act} + T_{store\_act}$). Lúc này, toàn bộ thời gian truyền tải dữ liệu (Activation và Weight) được che giấu hoàn toàn.

Công thức tổng quát:
\begin{equation}
    T_{total} = T_{load\_first\_pass} + \sum_{all\_passes} T_{comp} + T_{store\_residual}
\end{equation}

Việc tách biệt bộ nhớ Weight giúp giảm đáng kể khả năng rơi vào trạng thái Memory Bound so với kiến trúc Bus chung, đặc biệt là ở các lớp Fully Connected hoặc Convolution có số lượng tham số lớn.

\subsubsection{Tổng thời gian toàn mạng (Model Latency)}
Thời gian thực thi của toàn bộ mô hình (Model) bao gồm $N$ lớp tích chập là tổng thời gian của từng lớp:
\begin{equation}
    T_{model} = \sum_{i=1}^{N} T_{total}^{(i)}
\end{equation}